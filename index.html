<!DOCTYPE html>

<html>
<head>
  <title>shoreman.sh</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="public/stylesheets/normalize.css" />
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div class="container">
    <div class="page">

      <div class="header">
        
          <h1>shoreman.sh</h1>
        

        
      </div>

      
        
        
        
          <div class='highlight'><pre><span class="shebang">#!/bin/sh</span></pre></div>
        
      
        
        <p><a href="https://github.com/hecticjeff/shoreman">shoreman</a> is an
implementation of the <strong>Procfile</strong> format. Inspired by the original
<a href="http://ddollar.github.com/foreman/">foreman</a> tool for ruby, as
well as <a href="https://github.com/josh/norman">norman</a> for node.js.</p>

        
      
        
        <p>Make sure that any errors cause the script to exit immediately.</p>

        
          <div class='highlight'><pre><span class="keyword">set</span> -e
<span class="test_condition">[ <span class="string">"<span class="variable">$TRACE</span>"</span> ]</span> &amp;&amp; <span class="keyword">set</span> -x</pre></div>
        
      
        
        <h2>Usage</h2>

        
      
        
        <p>Usage message that is displayed when <code>--help</code> is given as an argument.</p>

        
          <div class='highlight'><pre>usage() {
  <span class="keyword">echo</span> <span class="string">"Usage: shoreman [procfile|Procfile] [envfile|.env]"</span>
  <span class="keyword">echo</span> <span class="string">"Run Procfiles using shell."</span>
  <span class="keyword">echo</span>
  <span class="keyword">echo</span> <span class="string">"The shoreman script reads commands from [procfile] and starts up the"</span>
  <span class="keyword">echo</span> <span class="string">"processes that it describes."</span>
}</pre></div>
        
      
        
        <h2>Logging</h2>

        
      
        
        <p>For logging we want to prefix each entry with the current time, as well
as the process name. This takes one argument, the name of the process, and
then reads data from stdin, formats it, and sends it to stdout.</p>

        
          <div class='highlight'><pre>log() {
  local pid=<span class="string">"$!"</span></pre></div>
        
      
        
        <p>Bash colors start from 31 up to 38. Instead of a hash set and storing a
bunch of variables, we will simply calculate what color the process will get
base on its PID</p>

        
          <div class='highlight'><pre>  local color=$((31 + (pid % 7)))

  <span class="keyword">while</span> read -r data
  <span class="keyword">do</span>
    printf <span class="string">"\033[1;%sm%s %s\033[0m"</span> <span class="string">"<span class="variable">$color</span>"</span> <span class="string">"$(date +"</span>%H:%M:%S<span class="string">")"</span> <span class="string">"<span class="variable">$1</span>"</span>
    printf <span class="string">"\t| %s\n"</span> <span class="string">"<span class="variable">$data</span>"</span>
  <span class="keyword">done</span>
}</pre></div>
        
      
        
        <h2>Running commands</h2>

        
      
        
        <p>When a process is started, we want to keep track of its pid so we can
<code>kill</code> it when the parent process receives a signal, and so we can <code>wait</code>
for it to finish before exiting the parent process.</p>

        
          <div class='highlight'><pre>store_pid() {
  pids=<span class="string">"<span class="variable">$pids</span> <span class="variable">$1</span>"</span>
}</pre></div>
        
      
        
        <p>This starts a command asynchronously and stores its pid in a list for use
later on in the script.</p>

        
          <div class='highlight'><pre>start_command() {
  sh -c <span class="string">"<span class="variable">$1</span>"</span> &amp;
  store_pid <span class="string">"$!"</span>
}</pre></div>
        
      
        
        <h2>Reading the .env file</h2>

        
      
        
        <p>The .env file needs to be a list of assignments like in a shell script.
Shell-style comments are permitted.</p>

        
          <div class='highlight'><pre>load_env_file() {</pre></div>
        
      
        
        <p>Set a default port before loading the .env file</p>

        
          <div class='highlight'><pre>  export PORT=<span class="variable">${PORT:-5000}</span>

  ENV_FILE=<span class="variable">${1:-'.env'}</span>
  <span class="keyword">if</span> <span class="test_condition">[ -f <span class="string">"<span class="variable">$ENV_FILE</span>"</span> ]</span>; <span class="keyword">then</span>
    export $(grep <span class="string">"^[^#]*=.*"</span> <span class="string">"<span class="variable">$ENV_FILE</span>"</span> | xargs)
  <span class="keyword">fi</span>
}</pre></div>
        
      
        
        <h2>Reading the Procfile</h2>

        
      
        
        <p>The Procfile needs to be parsed to extract the process names and commands.
The file is given on stdin, see the <code>&lt;</code> at the end of this while loop.</p>

        
          <div class='highlight'><pre>run_procfile() {
  local procfile=<span class="variable">${1:-'Procfile'}</span>
  <span class="keyword">while</span> read line || <span class="test_condition">[ -n <span class="string">"<span class="variable">$line</span>"</span> ]</span>; <span class="keyword">do</span>
    local name=<span class="string">"<span class="variable">${line%%:*}</span>"</span>
    local command=<span class="string">"<span class="variable">${line#*:[[:space:]]}</span>"</span>
    start_command <span class="string">"<span class="variable">$command</span>"</span> <span class="string">"<span class="variable">${name}</span>"</span>
    <span class="keyword">echo</span> <span class="string">"'<span class="variable">${command}</span>' started with pid $!"</span> | log <span class="string">"<span class="variable">${name}</span>"</span>
  <span class="keyword">done</span> &lt; <span class="string">"<span class="variable">$procfile</span>"</span>
}</pre></div>
        
      
        
        <h2>Cleanup</h2>

        
      
        
        <p>When a <code>SIGINT</code>, <code>SIGTERM</code> or <code>EXIT</code> is received, this action is run, killing the
child processes. The sleep stops STDOUT from pouring over the prompt, it
should probably go at some point.</p>

        
          <div class='highlight'><pre>onexit() {
  <span class="keyword">echo</span> SIGINT received
  <span class="keyword">echo</span> sending SIGTERM to all processes
  kill <span class="variable">$pids</span>
  sleep 1
}

main() {
  local procfile=<span class="string">"<span class="variable">$1</span>"</span>
  local env_file=<span class="string">"<span class="variable">$2</span>"</span></pre></div>
        
      
        
        <p>If the â€”help option is given, show the usage message and exit.</p>

        
          <div class='highlight'><pre>  expr -- <span class="string">"$*"</span> : <span class="string">".*--help"</span> &gt;/dev/null &amp;&amp; {
    usage
    <span class="keyword">exit</span> 0
  }

  load_env_file <span class="string">"<span class="variable">$env_file</span>"</span>
  run_procfile <span class="string">"<span class="variable">$procfile</span>"</span>

  trap onexit INT TERM</pre></div>
        
      
        
        <p>Wait for the children to finish executing before exiting.</p>

        
          <div class='highlight'><pre>  wait <span class="variable">$pids</span>
}

main <span class="string">"$@"</span></pre></div>
        
      
      <div class="fleur">h</div>
    </div>
  </div>
</body>
</html>
